<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>cannon.js - worker example using SharedArrayBuffer</title>
    <link rel="stylesheet" href="css/style.css" type="text/css" />
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" />
  </head>
  <body>
    <!-- Worker script, will be run in separate thread -->
    <script id="worker1" type="text/js-worker">
      import * as CANNON from '../dist/cannon-es.js'
      import { geometryToShape } from './js/three-conversion-utils.js'

      const dt = 1 / 60

      // The bodies passed down from three.js
      const bodies = []

      let positions
      let quaternions

      // Setup world
      const world = new CANNON.World()
      world.gravity.set(0, -10, 0)
      world.solver.tolerance = 0.001

      // Ground plane
      const groundShape = new CANNON.Plane()
      const groundBody = new CANNON.Body({ mass: 0 })
      groundBody.addShape(groundShape)
      groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0)
      world.addBody(groundBody)

      // When we get the init message
      self.addEventListener('message', (event) => {
        const { geometries, positionsSharedBuffer, quaternionsSharedBuffer } = event.data

        // Save the reference to the SharedArrayBuffer
        positions = new Float32Array(positionsSharedBuffer)
        quaternions = new Float32Array(quaternionsSharedBuffer)

        // Create the bodies from the three.js geometries
        for (let i = 0; i < geometries.length; i++) {
          const geometry = geometries[i]

          const shape = geometryToShape(geometry)
          const body = new CANNON.Body({ mass: 1 })
          body.addShape(shape)
          body.position.set(positions[i * 3 + 0], positions[i * 3 + 1], positions[i * 3 + 2])
          body.quaternion.set(
            quaternions[i * 4 + 0],
            quaternions[i * 4 + 1],
            quaternions[i * 4 + 2],
            quaternions[i * 4 + 3]
          )
          bodies.push(body)
          world.addBody(body)
        }

        // Start the loop
        setInterval(update, dt * 1000)
      })

      function update() {
        // Step the world
        world.step(dt)

        // Copy the cannon.js data into the buffers
        for (let i = 0; i < bodies.length; i++) {
          const body = bodies[i]

          positions[i * 3 + 0] = body.position.x
          positions[i * 3 + 1] = body.position.y
          positions[i * 3 + 2] = body.position.z
          quaternions[i * 4 + 0] = body.quaternion.x
          quaternions[i * 4 + 1] = body.quaternion.y
          quaternions[i * 4 + 2] = body.quaternion.z
          quaternions[i * 4 + 3] = body.quaternion.w
        }
      }
    </script>

    <script type="module">
      import * as CANNON from '../dist/cannon-es.js'
      import * as THREE from 'https://unpkg.com/three@0.122.0/build/three.module.js'
      import Stats from 'https://unpkg.com/three@0.122.0/examples/jsm/libs/stats.module.js'
      import { OrbitControls } from 'https://unpkg.com/three@0.122.0/examples/jsm/controls/OrbitControls.js'
      import { addTitle, addSourceButton } from './js/dom-utils.js'

      addTitle()
      addSourceButton()

      // Parameters
      const N = 40 // number of objects

      // Data arrays. Contains all our kinematic data we need for rendering.
      // SharedArrayBuffer are shared between the main
      // and worker thread. cannon.js will update the data while
      // three.js will read from them.
      const positionsSharedBuffer = new SharedArrayBuffer(N * 3 * Float32Array.BYTES_PER_ELEMENT)
      const quaternionsSharedBuffer = new SharedArrayBuffer(N * 4 * Float32Array.BYTES_PER_ELEMENT)
      const positions = new Float32Array(positionsSharedBuffer)
      const quaternions = new Float32Array(quaternionsSharedBuffer)

      // Get the worker code
      const workerScript = document
        .querySelector('#worker1')
        // BUG Somehow relative urls don't work in a module worker
        .textContent.replace(/from '\.\.\//g, `from '${window.location.origin}/`)
        .replace(/from '\.\//g, `from '${window.location.origin}/examples/`)

      // Create a blob for the inline worker code
      const blob = new Blob([workerScript], { type: 'text/javascript' })

      // Create worker
      const worker = new Worker(window.URL.createObjectURL(blob), { type: 'module' })

      worker.addEventListener('message', (event) => {
        console.log(event.data)
      })
      worker.addEventListener('error', (event) => {
        console.error(event.message)
      })

      // Initialize three.js
      let camera, scene, renderer, stats
      let controls

      // The meshes that will be passed to cannon.js
      const meshes = []

      initThree()
      initCannonWorker()
      animate()

      function initThree() {
        // Camera
        camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 0.5, 10000)
        camera.position.set(Math.cos(Math.PI / 5) * 30, 5, Math.sin(Math.PI / 5) * 30)

        // Scene
        scene = new THREE.Scene()
        scene.fog = new THREE.Fog(0x000000, 500, 10000)

        // Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true })
        renderer.setSize(window.innerWidth, window.innerHeight)
        renderer.setClearColor(scene.fog.color)

        renderer.shadowMap.enabled = true
        renderer.shadowMap.type = THREE.PCFSoftShadowMap

        renderer.outputEncoding = THREE.sRGBEncoding

        document.body.appendChild(renderer.domElement)

        // Stats.js
        stats = new Stats()
        document.body.appendChild(stats.dom)

        // Orbit controls
        controls = new OrbitControls(camera, renderer.domElement)
        controls.enableDamping = true
        controls.enablePan = false
        controls.dampingFactor = 0.3
        controls.minDistance = 10
        controls.maxDistance = 500

        // Lights
        const ambientLight = new THREE.AmbientLight(0x666666)
        scene.add(ambientLight)

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.75)

        const distance = 20
        directionalLight.position.set(distance, distance, distance)

        directionalLight.castShadow = true

        directionalLight.shadow.mapSize.width = 1024
        directionalLight.shadow.mapSize.height = 1024

        directionalLight.shadow.camera.left = -distance
        directionalLight.shadow.camera.right = distance
        directionalLight.shadow.camera.top = distance
        directionalLight.shadow.camera.bottom = -distance

        directionalLight.shadow.camera.far = 3 * distance
        directionalLight.shadow.camera.near = distance

        scene.add(directionalLight)

        // Floor
        const floorGeometry = new THREE.PlaneGeometry(100, 100, 1, 1)
        floorGeometry.rotateX(-Math.PI / 2)
        const floorMaterial = new THREE.MeshLambertMaterial({ color: 0x777777 })
        const floor = new THREE.Mesh(floorGeometry, floorMaterial)
        floor.receiveShadow = true
        scene.add(floor)

        // Cubes
        const cubeGeometry = new THREE.BoxGeometry(1, 1, 1, 10, 10)
        const cubeMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 })
        for (let i = 0; i < N; i++) {
          const cubeMesh = new THREE.Mesh(cubeGeometry, cubeMaterial)
          cubeMesh.position.set(Math.random() - 0.5, i * 2.5 + 0.5, Math.random() - 0.5)
          cubeMesh.castShadow = true
          meshes.push(cubeMesh)
          scene.add(cubeMesh)
        }

        window.addEventListener('resize', onWindowResize)
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight
        camera.updateProjectionMatrix()
        renderer.setSize(window.innerWidth, window.innerHeight)
      }

      function initCannonWorker() {
        // Copy the initial meshes data into the buffers
        for (let i = 0; i < meshes.length; i++) {
          const mesh = meshes[i]

          positions[i * 3 + 0] = mesh.position.x
          positions[i * 3 + 1] = mesh.position.y
          positions[i * 3 + 2] = mesh.position.z
          quaternions[i * 4 + 0] = mesh.quaternion.x
          quaternions[i * 4 + 1] = mesh.quaternion.y
          quaternions[i * 4 + 2] = mesh.quaternion.z
          quaternions[i * 4 + 3] = mesh.quaternion.w
        }

        // Send the geometry data to setup the cannon.js bodies and
        // the initial position and rotation data
        worker.postMessage({
          geometries: meshes.map((m) => m.geometry),
          positionsSharedBuffer,
          quaternionsSharedBuffer,
        })
      }

      function animate() {
        requestAnimationFrame(animate)

        // Update the three.js meshes
        for (let i = 0; i < meshes.length; i++) {
          meshes[i].position.set(positions[i * 3 + 0], positions[i * 3 + 1], positions[i * 3 + 2])
          meshes[i].quaternion.set(
            quaternions[i * 4 + 0],
            quaternions[i * 4 + 1],
            quaternions[i * 4 + 2],
            quaternions[i * 4 + 3]
          )
        }

        controls.update()
        renderer.render(scene, camera)
        stats.update()
      }
    </script>
  </body>
</html>
